<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å°„é¾é–€ Pro - æ——è‰¦æ­£å¼ç‰ˆ</title>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>
    <style>
        :root { --gold: #d4af37; --dark-green: #1a472a; --card-red: #e74c3c; }
        body { background: var(--dark-green); color: white; font-family: 'Segoe UI', sans-serif; text-align: center; margin: 0; padding: 10px; overflow-x: hidden; }
        .game-container { max-width: 1000px; margin: auto; }

        /* ç©å®¶åˆ—è¡¨ UI */
        .player-toggle-btn { background: rgba(0,0,0,0.5); border: 1px solid var(--gold); color: var(--gold); padding: 5px 15px; border-radius: 20px; margin-bottom: 10px; cursor: pointer; }
        .player-list { display: flex; justify-content: center; gap: 8px; flex-wrap: wrap; min-height: 50px; }
        .player-card { background: rgba(0,0,0,0.8); padding: 8px; border-radius: 10px; border: 2px solid #444; width: 115px; position: relative; font-size: 0.9rem; }
        .player-card.active { border-color: var(--gold); box-shadow: 0 0 10px var(--gold); background: rgba(212, 175, 55, 0.1); }
        .player-balance { color: #2ecc71; font-weight: bold; }
        .timer-display { color: #ff7675; font-size: 0.8rem; font-weight: bold; margin-top: 3px; }
        .is-host-icon { color: var(--gold); margin-left: 3px; font-weight: bold; }
        .kick-btn { position: absolute; top: -5px; right: -5px; background: #e74c3c; color: white; border-radius: 50%; width: 22px; height: 22px; border: 1px solid white; display: none; cursor: pointer; font-size: 14px; line-height: 18px; z-index: 5; }
        body.is-host .player-card:not(.is-me) .kick-btn { display: block; }

        .board { background: radial-gradient(circle, #2d5a3c 0%, #1a472a 100%); padding: 20px; border-radius: 40px; border: 4px solid var(--gold); margin-top: 10px; }
        .pool-display { font-size: 40px; color: #f1c40f; font-weight: bold; margin: 5px 0; }

        /* â”€â”€ ç‰Œå€æ’ç‰ˆï¼šå·¦æŸ± | é¾é–€ | å³æŸ± â”€â”€ */
        .card-wrapper { display: flex; flex-direction: column; align-items: center; gap: 4px; }
        .card-label { font-size: 0.75rem; color: #aaa; letter-spacing: 1px; height: 16px; }
        .card-label.gate-label { color: var(--gold); font-weight: bold; font-size: 0.85rem; }

        .gate-wrapper { display: flex; flex-direction: column; align-items: center; gap: 4px; position: relative; }
        .gate-frame {
            width: clamp(70px, 15vw, 90px); height: 130px;
            border: 2px dashed rgba(212,175,55,0.5); border-radius: 10px;
            display: flex; align-items: center; justify-content: center;
            background: rgba(212,175,55,0.05); position: relative;
            overflow: visible;
        }
        .gate-frame .gate-inner-text { color: rgba(212,175,55,0.35); font-size: 0.7rem; letter-spacing: 1px; }

        .card { width: clamp(70px, 15vw, 90px); height: 130px; background: white; border-radius: 10px; color: black; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 30px; font-weight: bold; border: 2px solid #333; box-shadow: 3px 3px 8px rgba(0,0,0,0.3); white-space: pre-wrap; transition: transform 0.2s; }
        .card.hidden { background: #2c3e50; color: transparent; border: 1px solid #7f8c8d; }
        .card.red { color: var(--card-red); }

        /* å‹è²  CSS å‹•ç•« */
        @keyframes winPulse {
            0%   { transform: scale(1); box-shadow: 3px 3px 8px rgba(0,0,0,0.3); }
            40%  { transform: scale(1.18); box-shadow: 0 0 30px #2ecc71, 0 0 60px #2ecc71; }
            100% { transform: scale(1); box-shadow: 3px 3px 8px rgba(0,0,0,0.3); }
        }
        @keyframes losePulse {
            0%   { transform: scale(1); }
            20%  { transform: translateX(-8px) scale(1.05); box-shadow: 0 0 25px var(--card-red); }
            40%  { transform: translateX(8px) scale(1.05); box-shadow: 0 0 25px var(--card-red); }
            60%  { transform: translateX(-5px); }
            80%  { transform: translateX(5px); }
            100% { transform: scale(1); box-shadow: 3px 3px 8px rgba(0,0,0,0.3); }
        }
        @keyframes crashPulse {
            0%   { transform: scale(1); }
            30%  { transform: scale(1.2) rotate(-5deg); box-shadow: 0 0 40px #f39c12, 0 0 80px #f39c12; }
            60%  { transform: scale(1.1) rotate(5deg); }
            100% { transform: scale(1); }
        }
        .card.anim-win   { animation: winPulse 0.7s ease-out; }
        .card.anim-lose  { animation: losePulse 0.7s ease-out; }
        .card.anim-crash { animation: crashPulse 0.7s ease-out; }

        /* å°„é–€é£›ç‰Œ Canvas */
        #shot-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 7000; }

        /* é–€æŸ±é€£æ¥ç·š */
        .cards-row { display: flex; justify-content: center; align-items: center; gap: 0; margin: 15px 0; height: 160px; position: relative; }
        .post-connector { width: 30px; height: 4px; background: linear-gradient(90deg, rgba(212,175,55,0.6), rgba(212,175,55,0.2)); align-self: center; flex-shrink: 0; }
        .post-connector.right { background: linear-gradient(90deg, rgba(212,175,55,0.2), rgba(212,175,55,0.6)); }

        /* çµæœæ©«å¹… */
        #result-banner { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.5); z-index: 8000; background: rgba(0,0,0,0.92); border-radius: 20px; padding: 20px 40px; border: 3px solid var(--gold); text-align: center; transition: transform 0.35s cubic-bezier(0.175,0.885,0.32,1.275), opacity 0.35s; opacity: 0; pointer-events: none; }
        #result-banner.show { display: block; transform: translate(-50%, -50%) scale(1); opacity: 1; }
        #result-banner .rb-emoji  { font-size: 3rem; }
        #result-banner .rb-text   { font-size: 1.8rem; font-weight: bold; margin: 5px 0; }
        #result-banner .rb-amount { font-size: 2.2rem; font-weight: bold; }
        #result-banner .rb-amount.positive { color: #2ecc71; }
        #result-banner .rb-amount.negative { color: var(--card-red); }

        /* å½©ç´™ */
        .confetti-piece { position: fixed; width: 10px; height: 14px; top: -20px; border-radius: 2px; pointer-events: none; animation: confettiFall linear forwards; z-index: 7999; }
        @keyframes confettiFall {
            0%   { transform: translateY(0) rotate(0deg); opacity: 1; }
            100% { transform: translateY(110vh) rotate(720deg); opacity: 0; }
        }

        .setup-box { background: rgba(0,0,0,0.8); padding: 20px; border-radius: 20px; border: 2px solid var(--gold); margin-bottom: 15px; }
        .input-group { margin: 10px 0; display: flex; justify-content: center; align-items: center; gap: 8px; flex-wrap: wrap; }
        input[type="number"], select { padding: 8px; border-radius: 5px; border: none; text-align: center; }
        button { padding: 10px 15px; cursor: pointer; background: var(--gold); border: none; font-weight: bold; border-radius: 6px; color: #1a472a; margin: 3px; }

        #emoji-broadcast-area { position: fixed; top: 35%; left: 50%; transform: translate(-50%, -50%); pointer-events: none; z-index: 10000; }
        .broadcast-item { background: rgba(0,0,0,0.85); color: var(--gold); padding: 10px 20px; border-radius: 30px; margin-bottom: 5px; font-weight: bold; border: 2px solid var(--gold); animation: fadeUp 2.5s forwards; }

        /* ç±Œç¢¼è‡ªé©æ‡‰ */
        .chip-container { display: flex; justify-content: center; gap: 8px; margin: 10px 0; flex-wrap: wrap; }
        .chip-btn { background: none; border: none; padding: 0; cursor: pointer; transition: transform 0.1s; }
        .chip-btn:active { transform: scale(0.9); }
        .chip-btn img { width: clamp(48px, 13vw, 65px); height: clamp(48px, 13vw, 65px); border-radius: 50%; }
        #bet-amount { background: #222; color: var(--gold); border: 2px solid var(--gold); font-size: 1.3rem; width: 100px !important; border-radius: 8px; }

        .emoji-btn { font-size: 1.5rem; background: rgba(0,0,0,0.3); border: 1px solid #555; border-radius: 50%; width: 45px; height: 45px; cursor: pointer; }

        /* ALL IN éŠæˆ²å…§ç¢ºèª */
        #all-in-confirm-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.88); z-index: 9000; flex-direction: column; justify-content: center; align-items: center; }
        #all-in-confirm-overlay.show { display: flex; }
        #all-in-confirm-overlay .allin-box { background: linear-gradient(135deg, #1a1a1a, #2c0000); border: 3px solid var(--card-red); border-radius: 24px; padding: 30px 40px; text-align: center; animation: alinPop 0.3s cubic-bezier(0.175,0.885,0.32,1.275); }
        @keyframes alinPop { from { transform: scale(0.6); opacity:0; } to { transform: scale(1); opacity:1; } }
        #all-in-confirm-overlay h2 { font-size: 2rem; color: var(--card-red); margin: 0 0 8px; }
        #all-in-confirm-overlay p  { color: #ccc; margin: 0 0 20px; }
        #all-in-confirm-overlay .allin-amount { font-size: 2.5rem; color: var(--gold); font-weight: bold; margin-bottom: 20px; }
        .allin-yes { background: var(--card-red) !important; color: white !important; font-size: 1.1rem !important; padding: 12px 30px !important; }
        .allin-no  { background: #555 !important; color: white !important; font-size: 1.1rem !important; padding: 12px 30px !important; }

        #all-in-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 9999; flex-direction: column; justify-content: center; align-items: center; }

        /* è¼ªåˆ°ä½ ç™¼å…‰ */
        @keyframes myTurnGlow {
            0%, 100% { box-shadow: 0 0 12px var(--gold); }
            50%       { box-shadow: 0 0 30px var(--gold), 0 0 60px rgba(212,175,55,0.4); }
        }
        #main-board.my-turn { animation: myTurnGlow 1.5s ease-in-out infinite; }
        #my-turn-toast { display: none; position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); background: var(--gold); color: #1a472a; font-weight: bold; font-size: 1.1rem; padding: 10px 28px; border-radius: 30px; z-index: 8500; box-shadow: 0 4px 20px rgba(0,0,0,0.5); animation: toastBounce 0.4s ease-out; }
        @keyframes toastBounce { from { transform: translateX(-50%) translateY(40px); opacity:0; } to { transform: translateX(-50%) translateY(0); opacity:1; } }

        /* è£œåº•æ± é€šçŸ¥ */
        #refill-toast { display: none; position: fixed; top: 80px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.9); color: var(--gold); border: 2px solid var(--gold); font-size: 1rem; padding: 10px 24px; border-radius: 20px; z-index: 8500; text-align: center; }

        /* â•â• æ©¢åœ“ç‰Œæ¡Œ â•â• */
        #oval-wrap { position:relative; width:100%; max-width:700px; margin:8px auto 0; padding-top:60%; }
        #oval-table {
            position:absolute; inset:0;
            background: radial-gradient(ellipse at 50% 42%, #3a7a52 0%, #2d5a3c 55%, #1e4a30 100%);
            border-radius:50%;
            border:10px solid #8B6914;
            box-shadow: 0 0 0 3px #5a3a08, 0 0 0 6px #2a1a04, inset 0 0 50px rgba(0,0,0,0.35), 0 16px 48px rgba(0,0,0,0.7);
        }
        #oval-table::before { content:''; position:absolute; inset:0; border-radius:50%; background:repeating-linear-gradient(45deg,transparent,transparent 18px,rgba(255,255,255,0.012) 18px,rgba(255,255,255,0.012) 19px); pointer-events:none; }
        @keyframes tableGlow {
            0%,100%{ box-shadow:0 0 0 3px #5a3a08, 0 0 0 6px #2a1a04, inset 0 0 50px rgba(0,0,0,0.35), 0 16px 48px rgba(0,0,0,0.7); }
            50%    { box-shadow:0 0 0 3px var(--gold), 0 0 0 10px rgba(212,175,55,0.25), inset 0 0 50px rgba(0,0,0,0.35), 0 16px 48px rgba(0,0,0,0.7); }
        }
        #oval-table.my-turn { animation:tableGlow 1.5s ease-in-out infinite; }
        #oval-info { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); text-align:center; z-index:5; pointer-events:none; }
        #oval-pool-text { font-size:clamp(14px,3vw,22px); color:#f1c40f; font-weight:bold; text-shadow:0 1px 6px rgba(0,0,0,0.8); }
        /* åº§ä½ */
        .seat-node { position:absolute; transform:translate(-50%,-50%); text-align:center; z-index:20; }
        .seat-box { background:rgba(0,0,0,0.82); border:2px solid #555; border-radius:10px; padding:4px 7px; font-size:clamp(9px,1.9vw,12px); min-width:clamp(55px,12vw,85px); max-width:clamp(62px,14vw,92px); line-height:1.35; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
        .seat-box.active { border-color:var(--gold); box-shadow:0 0 9px var(--gold); background:rgba(212,175,55,0.12); }
        .seat-box.is-me  { border-color:#3498db; }
        .seat-box.active.is-me { border-color:var(--gold); }
        .seat-name { font-weight:bold; }
        .seat-bal  { color:#2ecc71; font-size:clamp(8px,1.7vw,11px); }
        .seat-tmr  { color:#ff7675; font-size:clamp(7px,1.5vw,10px); }
        .seat-kick { position:absolute; top:-5px; right:-5px; background:#e74c3c; color:white; border-radius:50%; width:18px; height:18px; border:1px solid white; display:none; cursor:pointer; font-size:11px; line-height:16px; z-index:25; }
        body.is-host .seat-node:not(.is-me) .seat-kick { display:block; }

        /* â•â• ç‰Œå † â•â• */
        #deck-wrap { margin-top:8px; }
        #deck-stack { position:relative; width:clamp(50px,10vw,66px); height:clamp(70px,14vw,92px); cursor:default; margin:0 auto; }
        .dk { position:absolute; width:100%; height:100%; border-radius:7px; border:1.5px solid #3a6a9f; }
        .dk:nth-child(1){ transform:translate(4px,4px); background:#182e49; }
        .dk:nth-child(2){ transform:translate(2px,2px); background:#1c3454; }
        .dk:nth-child(3){ transform:translate(0,0); background:linear-gradient(135deg,#2a4f80,#1e3a64); box-shadow:2px 2px 8px rgba(0,0,0,0.6); display:flex; align-items:center; justify-content:center; font-size:clamp(20px,4vw,30px); color:rgba(255,255,255,0.3); }
        #deck-stack.can-click { cursor:pointer; animation:deckPulse 1.1s ease-in-out infinite; }
        #deck-stack.can-click .dk:nth-child(3) { background:linear-gradient(135deg,#3a6faa,#2a4f80); box-shadow:0 0 14px rgba(212,175,55,0.6),2px 2px 8px rgba(0,0,0,0.6); border-color:var(--gold); }
        @keyframes deckPulse { 0%,100%{transform:scale(1);} 50%{transform:scale(1.08);} }
        #deck-badge { position:absolute; bottom:-7px; right:-7px; z-index:6; background:var(--gold); color:#1a472a; font-size:10px; font-weight:bold; border-radius:10px; padding:1px 5px; }
        #deck-hint { font-size:clamp(9px,1.8vw,11px); color:var(--gold); margin-top:4px; min-height:14px; opacity:0; transition:opacity 0.3s; }
        #deck-hint.show { opacity:1; }
    </style>
</head>
<body>

<canvas id="shot-canvas"></canvas>
<div id="emoji-broadcast-area"></div>

<!-- çµæœæ©«å¹… -->
<div id="result-banner">
    <div class="rb-emoji" id="rb-emoji">ğŸ‰</div>
    <div class="rb-text"  id="rb-text">å°„é€²ï¼</div>
    <div class="rb-amount" id="rb-amount">+$0</div>
</div>

<!-- ALL IN éŠæˆ²å…§ç¢ºèª -->
<div id="all-in-confirm-overlay">
    <div class="allin-box">
        <h2>ğŸ”¥ ALL IN ç¢ºèª</h2>
        <p>ä½ ç¢ºå®šè¦æŠ¼ä¸Šå…¨éƒ¨å½©é‡‘ï¼Ÿ</p>
        <div class="allin-amount" id="allin-pool-preview">$0</div>
        <div style="display:flex; gap:16px; justify-content:center;">
            <button class="allin-yes" onclick="confirmAllIn()">ğŸ’¥ æˆ‘è¦å…¨éƒ¨ï¼</button>
            <button class="allin-no"  onclick="cancelAllIn()">å–æ¶ˆ</button>
        </div>
    </div>
</div>

<div id="all-in-overlay"><div id="video-box"></div><h1 style="color:var(--gold); margin-top: 20px;">æˆ‘è¦å…¨éƒ¨ï¼ï¼ï¼</h1></div>

<div id="refill-toast"></div>
<div id="my-turn-toast">ğŸ¯ è¼ªåˆ°ä½ äº†ï¼</div>

<!-- éŸ³æ•ˆ -->
<audio id="sfx-win"   src="sfx/win.mp3"   preload="auto"></audio>
<audio id="sfx-lose"  src="sfx/lose.mp3"  preload="auto"></audio>
<audio id="sfx-crash" src="sfx/crash.mp3" preload="auto"></audio>
<audio id="sfx-fold"  src="sfx/fold.mp3"  preload="auto"></audio>
<audio id="sfx-allin" src="sfx/allin.mp3" preload="auto"></audio>
<audio id="sfx-deal"  src="sfx/deal.mp3"  preload="auto"></audio>

<div class="game-container">
    <h1>ğŸŸï¸ åŸ”å¢˜é‡‘é¾é–€ Pro</h1>

    <div id="setup-area" class="setup-box">
        <div id="login-part">
            <input type="text" id="my-name" placeholder="è¼¸å…¥æš±ç¨±">
            <button onclick="joinRoom()">é€²å…¥å¤§å»³</button>
        </div>
        <div id="host-part" style="display:none;">
            <h3>ğŸ‘‘ æˆ¿ä¸»è¦å‰‡è¨­å®š</h3>
            <div class="input-group">
                åˆå§‹æœ¬é‡‘: <input type="number" id="start-balance" value="1000" style="width:80px;">
                é–‹å±€åº•æ³¨: <input type="number" id="entry-fee" value="100" style="width:70px;">
            </div>
            <div class="input-group">
                æ£„ç‰ŒæŠ•æ³¨: <input type="number" id="fold-penalty" value="20" style="width:70px;">
                ç‰Œçµ„æ•¸é‡: <select id="deck-count">
                    <option value="1">1 å‰¯ç‰Œ</option><option value="2" selected>2 å‰¯ç‰Œ</option>
                    <option value="3">3 å‰¯ç‰Œ</option><option value="4">4 å‰¯ç‰Œ</option>
                </select>
            </div>
            <div class="input-group">
                <label><input type="checkbox" id="auto-refill" checked> æ± é‡‘ä¸è¶³è‡ªå‹•è£œåº•</label>
            </div>
            <button onclick="hostStartGame()" style="background:#2ecc71; color:white; width: 90%; font-size: 1.1rem;">âœ… ç¢ºèªä¸¦é–‹æ¡Œ</button>
        </div>
    </div>

    <button class="player-toggle-btn" onclick="togglePlayers()">ğŸ‘¥ é¡¯ç¤º/éš±è—ç©å®¶åˆ—è¡¨</button>
    <div id="player-area-wrapper"><div id="player-area" class="player-list"></div></div>

    <!-- æ©¢åœ“ç‰Œæ¡Œ -->
    <div id="oval-wrap" style="display:none;">
        <div id="oval-table">
            <div id="oval-info">
                <div id="oval-pool-text">ğŸ’° $0</div>
                <div id="deck-wrap">
                    <div id="deck-stack" onclick="onDeckClick()">
                        <div class="dk"></div>
                        <div class="dk"></div>
                        <div class="dk">ğŸ‚ <span id="deck-badge">0</span></div>
                    </div>
                    <div id="deck-hint">é»æ“ŠæŠ½ç‰Œ</div>
                </div>
            </div>
            <div id="seats-layer"></div>
        </div>
    </div>

    <div id="main-board" class="board" style="display:none;">
        <div class="emoji-bar">
            <button class="emoji-btn" onclick="sendEmoji('ğŸ˜‚')">ğŸ˜‚</button>
            <button class="emoji-btn" onclick="sendEmoji('ğŸ”¥')">ğŸ”¥</button>
            <button class="emoji-btn" onclick="sendEmoji('ğŸ’¸')">ğŸ’¸</button>
            <button class="emoji-btn" onclick="sendEmoji('ğŸ’©')">ğŸ’©</button>
            <button class="emoji-btn" onclick="sendEmoji('ğŸƒ')">ğŸƒ</button>
        </div>

        <div class="pool-display">ğŸ’° $<span id="pool-val">0</span></div>
        <div id="status-msg">ç­‰å¾…ç™¼ç‰Œ...</div>

        <!-- å·¦æŸ± | é¾é–€ | å³æŸ± -->
        <div class="cards-row">
            <div class="card-wrapper">
                <div class="card-label">å·¦æŸ±</div>
                <div id="c1" class="card hidden">?</div>
            </div>

            <div class="post-connector"></div>

            <div class="gate-wrapper">
                <div class="card-label gate-label">ğŸ‰ é¾é–€</div>
                <div class="gate-frame" id="gate-frame">
                    <span class="gate-inner-text" id="gate-inner">å¾…å°„é–€</span>
                    <div id="c3-in-gate" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); z-index:10;"></div>
                </div>
            </div>

            <div class="post-connector right"></div>

            <div class="card-wrapper">
                <div class="card-label">å³æŸ±</div>
                <div id="c2" class="card hidden">?</div>
            </div>
        </div>

        <div id="controls">
            <div id="bet-controls" style="display:none;">
                <div class="chip-container">
                    <button class="chip-btn" onclick="addBet(10)"><img src="pic/m10.jpg"></button>
                    <button class="chip-btn" onclick="addBet(50)"><img src="pic/m50.jpg"></button>
                    <button class="chip-btn" onclick="addBet(100)"><img src="pic/m100.jpg"></button>
                    <button class="chip-btn" onclick="addBet(500)"><img src="pic/m500.jpg"></button>
                    <button class="chip-btn" onclick="addBet(1000)"><img src="pic/m1000.jpg"></button>
                </div>
                <div style="margin-bottom: 10px;">
                    ä¸‹æ³¨é‡‘é¡ï¼š<input type="number" id="bet-amount" value="0" readonly>
                    <button onclick="document.getElementById('bet-amount').value=0" style="background:#555;">æ¸…ç©º</button>
                </div>
                <div id="action-buttons" style="display:inline-block;">
                    <button id="shoot-normal" onclick="handleAction('shoot')">å°„é–€ï¼</button>
                    <div id="guess-buttons" style="display:none;">
                        <button onclick="handleAction('up')" style="background:#3498db; color:white;">çŒœå¤§</button>
                        <button onclick="handleAction('down')" style="background:#e67e22; color:white;">çŒœå°</button>
                    </div>
                </div>
                <button onclick="setAllIn()" style="background:var(--card-red); color:white;">ALL IN</button>
                <button onclick="handleAction('fold')" style="background:#95a5a6;">æ”¾æ£„ ($<span id="fold-cost-ui">0</span>)</button>
            </div>
            <div id="player-deal-btn" style="display:none;">
                <button onclick="drawGoalPost()" style="background: #2ecc71; color: white; font-size: 1.2rem; padding: 12px 30px;">â™  ç«‹å³ç™¼ç‰Œ â™£</button>
            </div>
            <div id="host-controls" style="margin-top:20px; display:none; border-top:1px solid #555; padding-top:10px;">
                <button onclick="hostResetToLobby()" style="background: #e74c3c; color: white;">ğŸš¨ é‡è£½å¤§å»³ç‹€æ…‹</button>
            </div>
        </div>
        <p style="font-size: 12px; color: #aaa;">ğŸ´ ç‰Œåº«å‰©é¤˜: <span id="cards-left">0</span></p>
    </div>
</div>

<script>
    const firebaseConfig = {
        apiKey: "AIzaSyDzd-2ZUgrDM8K_85_qSOgpkWuWNzBUBL8",
        authDomain: "dargongatepoker.firebaseapp.com",
        databaseURL: "https://dargongatepoker-default-rtdb.firebaseio.com",
        projectId: "dargongatepoker",
        storageBucket: "dargongatepoker.firebasestorage.app",
        messagingSenderId: "204663560828",
        appId: "1:204663560828:web:9ede7b6190babde73f07f9"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
    const gameRef = db.ref('dragonGate/room1');

    // æ¯æ¬¡ joinRoom éƒ½ç”¢ç”Ÿæ–° IDï¼Œä¸ç¹¼æ‰¿ localStorage
    let myId = "";
    let localData = {};
    let lastEffectId = "INITIAL";
    let lastShotId = "INITIAL";
    let lastEmojiTime = 0;
    let serverOffset = 0;
    let wasMyturn = false;
    const labels = {1:'A', 11:'J', 12:'Q', 13:'K'};

    db.ref(".info/serverTimeOffset").on("value", s => serverOffset = s.val());
    function getServerNow() { return Date.now() + serverOffset; }

    // éŸ³æ•ˆæ’­æ”¾
    function playSfx(id) {
        const el = document.getElementById(id);
        if (!el) return;
        el.currentTime = 0;
        el.play().catch(() => {});
    }

    // å°„é–€é£›ç‰Œå‹•ç•«ï¼ˆCanvasï¼‰
    function animateShotCard(cardData, resultType, onDone) {
        const canvas = document.getElementById('shot-canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const gateEl = document.getElementById('gate-frame');
        const gateRect = gateEl.getBoundingClientRect();
        const gateX = gateRect.left + gateRect.width / 2;
        const gateY = gateRect.top + gateRect.height / 2;

        const c1Rect = document.getElementById('c1').getBoundingClientRect();
        const c2Rect = document.getElementById('c2').getBoundingClientRect();
        const leftPostX  = c1Rect.left + c1Rect.width / 2;
        const rightPostX = c2Rect.left + c2Rect.width / 2;

        const isRed = cardData.suit === 'â™¥' || cardData.suit === 'â™¦';
        const cardW = 70, cardH = 100;

        let startX = canvas.width / 2;
        let startY = canvas.height + 80;

        let endX, endY;
        if (resultType === 'win') {
            endX = gateX; endY = gateY;
        } else if (resultType === 'crash') {
            const hitLeft = Math.random() > 0.5;
            endX = hitLeft ? leftPostX : rightPostX;
            endY = gateY;
        } else {
            endX = Math.random() > 0.5 ? -cardW : canvas.width + cardW;
            endY = gateY - 40;
        }

        const cpX = (startX + endX) / 2 + (Math.random() - 0.5) * 80;
        const cpY = Math.min(startY, endY) - 200;

        let t = 0;
        const duration = 50;
        let rotation = 0;

        function drawCard(x, y, rot, alpha) {
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.translate(x, y);
            ctx.rotate(rot);
            ctx.fillStyle = '#fff';
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            roundRect(ctx, -cardW/2, -cardH/2, cardW, cardH, 8);
            ctx.fill(); ctx.stroke();
            ctx.fillStyle = isRed ? '#e74c3c' : '#000';
            ctx.font = `bold 22px 'Segoe UI'`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(cardData.suit, 0, -12);
            ctx.fillText(cardData.label.toString(), 0, 16);
            ctx.restore();
        }

        function roundRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        }

        let particles = [];

        function spawnCrashParticles(x, y) {
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 3 + Math.random() * 6;
                particles.push({
                    x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
                    life: 1, color: Math.random() > 0.5 ? '#f39c12' : '#e74c3c'
                });
            }
        }

        let phase = 'fly';
        let impactTimer = 0;

        function frame() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (phase === 'fly') {
                t++;
                const p = t / duration;
                const eased = p < 0.5 ? 2 * p * p : -1 + (4 - 2 * p) * p;
                const bx = (1-eased)*(1-eased)*startX + 2*(1-eased)*eased*cpX + eased*eased*endX;
                const by = (1-eased)*(1-eased)*startY + 2*(1-eased)*eased*cpY + eased*eased*endY;
                rotation += 0.15;
                const alpha = Math.min(1, p * 3);
                drawCard(bx, by, rotation, alpha);
                if (t >= duration) {
                    phase = 'impact';
                    if (resultType === 'crash') spawnCrashParticles(endX, endY);
                }
                requestAnimationFrame(frame);

            } else if (phase === 'impact') {
                impactTimer++;

                if (resultType === 'win') {
                    const scale = 1 - impactTimer / 25;
                    const alpha = 1 - impactTimer / 20;
                    if (alpha > 0) {
                        ctx.save();
                        ctx.strokeStyle = `rgba(46,204,113,${alpha})`;
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(endX, endY, 50 + impactTimer * 3, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.restore();
                        drawCard(endX, endY, 0, alpha * scale);
                    }
                } else if (resultType === 'crash') {
                    particles.forEach(p => {
                        p.x += p.vx; p.y += p.vy;
                        p.vy += 0.3;
                        p.life -= 0.04;
                        ctx.save();
                        ctx.globalAlpha = p.life;
                        ctx.fillStyle = p.color;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    });
                    particles = particles.filter(p => p.life > 0);
                    const shakeX = (Math.random() - 0.5) * (10 - impactTimer * 0.5);
                    drawCard(endX + shakeX, endY, Math.random() * 0.3, Math.max(0, 1 - impactTimer / 20));
                } else {
                    const alpha = Math.max(0, 1 - impactTimer / 15);
                    const fly = impactTimer * 8;
                    const dir = endX < canvas.width / 2 ? -1 : 1;
                    drawCard(endX + dir * fly, endY - fly * 0.3, rotation + impactTimer * 0.2, alpha);
                }

                if (impactTimer >= 25 || (resultType === 'lose' && impactTimer >= 18)) {
                    phase = 'done';
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    if (onDone) onDone();
                    return;
                }
                requestAnimationFrame(frame);
            }
        }
        requestAnimationFrame(frame);
    }

    // çµæœæ©«å¹…
    function showResultBanner(emoji, text, amount, type) {
        const banner = document.getElementById('result-banner');
        document.getElementById('rb-emoji').innerText = emoji;
        document.getElementById('rb-text').innerText = text;
        const amtEl = document.getElementById('rb-amount');
        amtEl.innerText = (amount >= 0 ? '+' : '') + '$' + amount;
        amtEl.className = 'rb-amount ' + (amount >= 0 ? 'positive' : 'negative');
        banner.classList.remove('show');
        banner.style.display = 'block';
        requestAnimationFrame(() => { requestAnimationFrame(() => { banner.classList.add('show'); }); });
        setTimeout(() => { banner.classList.remove('show'); setTimeout(() => { banner.style.display = 'none'; }, 400); }, 2800);
    }

    // å½©ç´™
    function spawnConfetti(count) {
        const colors = ['#f1c40f','#2ecc71','#3498db','#e74c3c','#9b59b6','#fff'];
        for (let i = 0; i < count; i++) {
            const el = document.createElement('div');
            el.className = 'confetti-piece';
            el.style.left = Math.random() * 100 + 'vw';
            el.style.background = colors[Math.floor(Math.random() * colors.length)];
            el.style.animationDuration = (1.5 + Math.random() * 1.5) + 's';
            el.style.animationDelay = (Math.random() * 0.5) + 's';
            el.style.transform = `rotate(${Math.random()*360}deg)`;
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 3500);
        }
    }

    // è¼ªåˆ°ä½ çš„ Toast
    let myTurnToastTimer = null;
    function showMyTurnToast() {
        const t = document.getElementById('my-turn-toast');
        t.style.display = 'block';
        if ('vibrate' in navigator) navigator.vibrate([150, 50, 150]);
        clearTimeout(myTurnToastTimer);
        myTurnToastTimer = setTimeout(() => { t.style.display = 'none'; }, 3000);
    }

    // è£œåº•æ± é€šçŸ¥
    let refillToastTimer = null;
    function showRefillToast(fee, count) {
        const t = document.getElementById('refill-toast');
        t.innerText = `ğŸ’° æ± é‡‘ä¸è¶³ï¼Œæ¯äººè£œåº• $${fee}ï¼ˆå…±è£œ $${fee * count}ï¼‰`;
        t.style.display = 'block';
        clearTimeout(refillToastTimer);
        refillToastTimer = setTimeout(() => { t.style.display = 'none'; }, 3500);
    }

    // æ¯ 5 ç§’æ›´æ–°æ´»èºæ™‚é–“
    setInterval(() => {
        if (myId && localData.players && localData.players[myId]) {
            gameRef.child('players/'+myId).update({ lastActive: getServerNow() });
        }
    }, 5000);

    // æ ¸å¿ƒå¾ªç’°ï¼šæ¯ç§’æª¢æŸ¥ç‹€æ…‹èˆ‡æ¸…ç†
    setInterval(() => {
        if (!localData.players) return;
        const now = getServerNow();
        const players = localData.players;
        const pKeys = Object.keys(players);

        if (pKeys[0] === myId) {
            pKeys.forEach(id => {
                if (id !== myId && (!players[id].lastActive || now - players[id].lastActive > 60000)) {
                    gameRef.child('players/' + id).remove();
                }
            });
        }

        if (pKeys.length === 0 && localData.gameStarted) {
            gameRef.update({ gameStarted: false, c1:null, c2:null, c3:null });
            return;
        }

        if (!localData.gameStarted) return;

        const cpKey = localData.currentPlayerKey;
        if (cpKey && !players[cpKey]) {
            gameRef.update({ gameState: 'waiting_deal', currentPlayerKey: pKeys[0], lastActionTime: firebase.database.ServerValue.TIMESTAMP });
            return;
        }

        if (pKeys[0] === myId && localData.lastActionTime) {
            const diff = (now - localData.lastActionTime) / 1000;
            if (diff > 60.5) {
                gameRef.child('players/' + cpKey).remove().then(() => {
                    const nextKeys = Object.keys(localData.players).filter(k => k !== cpKey);
                    gameRef.update({
                        gameState: 'waiting_deal', currentPlayerKey: nextKeys[0] || null,
                        statusMsg: "ç©å®¶è¶…æ™‚è¸¢é™¤", lastActionTime: firebase.database.ServerValue.TIMESTAMP
                    });
                });
            }
        }
        renderPlayers();
        renderSeats();
    }, 1000);


    // â•â• é»æ“Šç‰Œå †æŠ½ç‰Œ â•â•
    function onDeckClick() {
        if (!localData.gameStarted) return;
        if (localData.currentPlayerKey !== myId) return;
        if (localData.gameState === 'waiting_deal') {
            drawGoalPost();
        } else if (localData.gameState === 'waiting_shoot') {
            const bet = Math.abs(parseInt(document.getElementById('bet-amount').value)) || 0;
            const isSame = localData.c1 && localData.c2 && localData.c1.val === localData.c2.val;
            if (bet < 1 || bet > localData.pool) {
                const h = document.getElementById('deck-hint');
                h.innerText = 'âš ï¸ è«‹å…ˆä¸‹æ³¨ï¼'; h.classList.add('show');
                setTimeout(() => { h.innerText = 'ä¸‹æ³¨å¾Œé»æ“Šå°„é–€'; }, 1500);
                return;
            }
            if (isSame) {
                const h = document.getElementById('deck-hint');
                h.innerText = 'âš ï¸ è«‹å…ˆçŒœå¤§æˆ–çŒœå°'; h.classList.add('show');
                setTimeout(() => { h.innerText = 'ä¸‹æ³¨å¾Œé»æ“Šå°„é–€'; }, 1500);
            } else {
                handleAction('shoot');
            }
        }
    }

    function togglePlayers() {
        const w = document.getElementById('player-area-wrapper');
        w.style.display = (w.style.display === 'none') ? 'block' : 'none';
    }

    function joinRoom() {
        const name = document.getElementById('my-name').value.trim();
        if (!name) return alert("è«‹è¼¸å…¥æš±ç¨±");

        const now = getServerNow();
        gameRef.once('value', snap => {
            const data = snap.val() || {};
            const players = data.players || {};

            Object.keys(players).forEach(id => {
                if (!players[id].lastActive || now - players[id].lastActive > 60000) {
                    delete players[id];
                    gameRef.child('players/' + id).remove();
                }
            });

            const pKeys = Object.keys(players);
            if (pKeys.length === 0) {
                gameRef.update({ gameStarted: false, c1:null, c2:null, c3:null, currentPlayerKey: null });
            }

            // æ¯æ¬¡é€²å…¥éƒ½å¼·åˆ¶ç”¢ç”Ÿæ–° ID
            const newRef = gameRef.child('players').push();
            myId = newRef.key;

            gameRef.child('players/'+myId).update({ name: name, balance: 0, lastActive: now });

            if(data.allInTrigger) lastEffectId = data.allInTrigger;
            if(data.lastEmoji) lastEmojiTime = data.lastEmoji.time;
            if(data.lastShot) lastShotId = data.lastShot.id;

            startListening();
            document.getElementById('login-part').style.display = 'none';
        });
    }

    function startListening() {
        gameRef.on('value', snap => {
            localData = snap.val() || {};
            if (!localData.players || !localData.players[myId]) return;

            const pKeys = Object.keys(localData.players);
            const isHost = (pKeys[0] === myId);
            document.body.className = isHost ? "is-host" : "";

            if (localData.lastEmoji && localData.lastEmoji.time > lastEmojiTime) {
                showEmojiBroadcast(localData.lastEmoji.name, localData.lastEmoji.icon);
                lastEmojiTime = localData.lastEmoji.time;
            }

            // å»£æ’­é£›ç‰Œï¼šéå°„é–€è€…æ”¶åˆ° lastShot æ™‚æ’­æ”¾å‹•ç•«
            if (localData.lastShot && localData.lastShot.id !== lastShotId) {
                const shot = localData.lastShot;
                lastShotId = shot.id;
                if (shot.shooterId !== myId) {
                    updateCard('c1', localData.c1);
                    updateCard('c2', localData.c2);
                    document.getElementById('gate-inner').style.display = 'none';
                    animateShotCard(shot.card, shot.resultType, () => {
                        updateGateCard(localData.c3);
                        const sfxMap = { win:'sfx-win', crash:'sfx-crash', lose:'sfx-lose' };
                        playSfx(sfxMap[shot.resultType] || 'sfx-lose');
                        if (shot.resultType === 'win') spawnConfetti(40);
                        showResultBanner(shot.emoji, shot.text, shot.delta, shot.resultType);
                    });
                }
            }

            if (localData.allInTrigger && localData.allInTrigger !== lastEffectId) {
                const v = document.getElementById('video-box');
                v.innerHTML = `<video width="315" height="560" autoplay playsinline><source src="video/allin.mp4" type="video/mp4"></video>`;
                document.getElementById('all-in-overlay').style.display = 'flex';
                playSfx('sfx-allin');
                setTimeout(() => { document.getElementById('all-in-overlay').style.display = 'none'; }, 2500);
                lastEffectId = localData.allInTrigger;
            }

            if (localData.gameStarted) {
                document.getElementById('setup-area').style.display = 'none';
                document.getElementById('oval-wrap').style.display = 'block';
                document.getElementById('main-board').style.display = 'block';
                renderUI(isHost);

                const isTurnNow = (localData.currentPlayerKey === myId);
                if (isTurnNow && !wasMyturn) showMyTurnToast();
                wasMyturn = isTurnNow;
            } else {
                document.getElementById('setup-area').style.display = 'block';
                document.getElementById('host-part').style.display = isHost ? 'block' : 'none';
                document.getElementById('oval-wrap').style.display = 'none';
                document.getElementById('main-board').style.display = 'none';
                wasMyturn = false;
            }
            document.getElementById('host-controls').style.display = isHost ? 'block' : 'none';
            renderPlayers();
            renderSeats();
        });
    }

    function sendEmoji(icon) {
        gameRef.update({ lastEmoji: { name: localData.players[myId].name, icon: icon, time: firebase.database.ServerValue.TIMESTAMP } });
    }

    function showEmojiBroadcast(name, icon) {
        const area = document.getElementById('emoji-broadcast-area');
        const div = document.createElement('div');
        div.className = 'broadcast-item';
        div.innerText = `${name}: ${icon}`;
        area.appendChild(div);
        setTimeout(() => div.remove(), 2500);
    }


    // â•â• æ©¢åœ“æ¡Œåº§ä½ï¼ˆè‡ªå·±æ°¸é åœ¨æœ€ä¸‹æ–¹ï¼‰â•â•
    function renderSeats() {
        const layer = document.getElementById('seats-layer');
        if (!layer || !localData.players) return;
        layer.innerHTML = '';
        const pKeys = Object.keys(localData.players);
        const n = pKeys.length;
        if (n === 0) return;
        const myIdx = pKeys.indexOf(myId);
        const rx = 43, ry = 40;
        pKeys.forEach((id, i) => {
            const p = localData.players[id];
            const isMe     = (id === myId);
            const isHost   = (i === 0);
            const isActive = (id === localData.currentPlayerKey);
            const relIdx   = (i - myIdx + n) % n;
            const angleRad = (90 + relIdx * (360/n)) * Math.PI / 180;
            const cx = 50 + rx * Math.cos(angleRad);
            const cy = 50 + ry * Math.sin(angleRad);
            const crown = isHost ? ' ğŸ‘‘' : '';
            let tmr = '';
            if (isActive && localData.lastActionTime) {
                const sec = Math.max(0, 60 - Math.floor((getServerNow()-localData.lastActionTime)/1000));
                tmr = `<div class="seat-tmr">â±${sec}s</div>`;
            }
            const boxCls = ['seat-box', isActive?'active':'', isMe?'is-me':''].filter(Boolean).join(' ');
            const node = document.createElement('div');
            node.className = 'seat-node' + (isMe?' is-me':'');
            node.style.left = cx+'%'; node.style.top = cy+'%';
            node.innerHTML = `<button class="seat-kick" onclick="kickPlayer('${id}')">âœ•</button><div class="${boxCls}"><div class="seat-name">${p.name}${crown}</div><div class="seat-bal">$${p.balance}</div>${tmr}</div>`;
            layer.appendChild(node);
        });
        const t = document.getElementById('oval-table');
        if (t) { if (localData.currentPlayerKey===myId) t.classList.add('my-turn'); else t.classList.remove('my-turn'); }
    }

    function renderPlayers() {
        const area = document.getElementById('player-area');
        if (!area) return;
        area.innerHTML = '';
        const players = localData.players || {};
        const pKeys = Object.keys(players);

        pKeys.forEach((id, index) => {
            const p = players[id];
            const isActive = (id === localData.currentPlayerKey);
            const isMe = (id === myId);
            const isRoomHost = (index === 0);
            const div = document.createElement('div');
            div.className = `player-card ${isActive ? 'active' : ''} ${isMe ? 'is-me' : ''}`;
            let crown = isRoomHost ? `<span class="is-host-icon">ğŸ‘‘</span>` : "";
            let timer = (isActive && localData.lastActionTime) ? `<div class="timer-display">â± ${Math.max(0, 60 - Math.floor((getServerNow() - localData.lastActionTime) / 1000))}s</div>` : "";
            div.innerHTML = `<button class="kick-btn" onclick="kickPlayer('${id}')">âœ•</button><b>${p.name}</b>${crown}<br><span class="player-balance">$${p.balance}</span>${timer}`;
            area.appendChild(div);
        });
    }

    function hostStartGame() {
        const fee = parseInt(document.getElementById('entry-fee').value) || 100;
        const start = parseInt(document.getElementById('start-balance').value) || 1000;
        const decks = parseInt(document.getElementById('deck-count').value) || 2;
        const refill = document.getElementById('auto-refill').checked;
        let players = localData.players, pool = 0;
        Object.keys(players).forEach(id => { players[id].balance = start - fee; pool += fee; });
        gameRef.update({
            gameStarted: true, deck: generateDecks(decks), pool: pool, entryFee: fee,
            foldPenalty: parseInt(document.getElementById('fold-penalty').value) || 20,
            autoRefill: refill, deckCount: decks, gameState: 'waiting_deal',
            currentPlayerKey: Object.keys(players)[0], players: players,
            lastActionTime: firebase.database.ServerValue.TIMESTAMP, statusMsg: "æ–°å±€é–‹å§‹"
        });
    }

    function drawGoalPost() {
        playSfx('sfx-deal');
        let deck = localData.deck || [];
        if (deck.length < 3) deck = generateDecks(localData.deckCount || 2);
        const c1 = deck.pop(); const c2 = deck.pop();
        gameRef.update({
            deck: deck, c1: c1, c2: c2, c3: null, gameState: 'waiting_shoot',
            lastActionTime: firebase.database.ServerValue.TIMESTAMP, statusMsg: "è«‹ä¸‹æ³¨"
        });
    }

    function handleAction(type) {
        let bet = Math.abs(parseInt(document.getElementById('bet-amount').value)) || 0;
        if (type !== 'fold' && (bet < 1 || bet > localData.pool)) return alert("è«‹ä¸‹æ³¨");
        let p = localData.players[myId], nBal = p.balance, nPool = localData.pool;
        let msg = "", c3 = null, deck = localData.deck || [];
        let resultType = 'neutral';
        let deltaAmount = 0;

        if (type === 'fold') {
            nBal -= localData.foldPenalty;
            nPool += localData.foldPenalty;
            msg = `${p.name} æ£„ç‰Œ`;
            resultType = 'fold';
            deltaAmount = -localData.foldPenalty;
        } else {
            if (deck.length < 1) deck = generateDecks(localData.deckCount || 2);
            c3 = deck.pop();
            const min = Math.min(localData.c1.val, localData.c2.val);
            const max = Math.max(localData.c1.val, localData.c2.val);

            if (localData.c1.val === localData.c2.val) {
                if (c3.val === localData.c1.val) {
                    nBal -= bet * 3; nPool += bet * 3;
                    msg = `æ’æŸ± (-$${bet * 3})`;
                    resultType = 'crash'; deltaAmount = -(bet * 3);
                } else if ((type === 'up' && c3.val > localData.c1.val) || (type === 'down' && c3.val < localData.c1.val)) {
                    nBal += bet; nPool -= bet;
                    msg = `çŒœå° (+$${bet})`;
                    resultType = 'win'; deltaAmount = bet;
                } else {
                    nBal -= bet; nPool += bet;
                    msg = `çŒœéŒ¯ (-$${bet})`;
                    resultType = 'lose'; deltaAmount = -bet;
                }
            } else {
                if (c3.val > min && c3.val < max) {
                    nBal += bet; nPool -= bet;
                    msg = `å°„é€² (+$${bet})`;
                    resultType = 'win'; deltaAmount = bet;
                } else if (c3.val === min || c3.val === max) {
                    nBal -= bet * 2; nPool += bet * 2;
                    msg = `æ’æŸ± (-$${bet * 2})`;
                    resultType = 'crash'; deltaAmount = -(bet * 2);
                } else {
                    nBal -= bet; nPool += bet;
                    msg = `æ²’é€² (-$${bet})`;
                    resultType = 'lose'; deltaAmount = -bet;
                }
            }
        }

        const pKeys = Object.keys(localData.players);
        let nextK = pKeys[(pKeys.indexOf(myId) + 1) % pKeys.length];

        // autoRefill ä¿®æ­£ç‰ˆ
        // æ¢ä»¶1ï¼šæœ‰å‹¾é¸ autoRefill ä¸”æ± é‡‘ä¸è¶³
        // æ¢ä»¶2ï¼šç„¡è«–æœ‰ç„¡å‹¾é¸ï¼Œæ± é‡‘æ­¸é›¶éƒ½è¦å¼·åˆ¶è£œåº•
        let updates = {
            [`players/${myId}/balance`]: nBal, pool: nPool, deck: deck, c3: c3 || null,
            statusMsg: msg, gameState: 'waiting_deal', currentPlayerKey: nextK,
            lastActionTime: firebase.database.ServerValue.TIMESTAMP
        };

        const minPoolNeeded = localData.entryFee * pKeys.length;
        const needRefill = (localData.autoRefill && nPool < minPoolNeeded) || (nPool <= 0);
        let refillTriggered = false;

        if (needRefill) {
            let totalRefill = 0;
            pKeys.forEach(k => {
                const currentBal = (k === myId) ? nBal : localData.players[k].balance;
                updates[`players/${k}/balance`] = currentBal - localData.entryFee;
                totalRefill += localData.entryFee;
            });
            updates.pool = nPool + totalRefill;
            refillTriggered = true;
        }

        // å»£æ’­é£›ç‰Œè³‡è¨Šçµ¦æ‰€æœ‰ç©å®¶
        if (type !== 'fold' && c3) {
            updates.lastShot = {
                id: Date.now().toString(),
                shooterId: myId,
                card: c3,
                resultType: resultType,
                emoji: resultType==='win'?'ğŸ‰': resultType==='crash'?'ğŸ’¥':'ğŸ˜­',
                text:  resultType==='win'? (type==='up'||type==='down'?'çŒœå°ï¼':'å°„é€²ï¼') : resultType==='crash'?'æ’æŸ±ï¼ï¼': (type==='up'||type==='down'?'çŒœéŒ¯äº†':'æ²’é€²...'),
                delta: deltaAmount
            };
        }

        // Firebase å…ˆé€å‡ºï¼Œæœ¬æ©Ÿå‹•ç•«ä¸¦è¡Œæ’­æ”¾
        gameRef.update(updates);
        document.getElementById('bet-amount').value = 0;

        if (type !== 'fold' && c3) {
            document.getElementById('gate-inner').style.display = 'none';
            animateShotCard(c3, resultType, () => {
                updateGateCard(c3);
                if (resultType === 'win') {
                    playSfx('sfx-win');
                    spawnConfetti(40);
                    showResultBanner('ğŸ‰', type === 'up' ? 'çŒœå°ï¼' : 'å°„é€²ï¼', deltaAmount, 'win');
                } else if (resultType === 'crash') {
                    playSfx('sfx-crash');
                    showResultBanner('ğŸ’¥', 'æ’æŸ±ï¼ï¼', deltaAmount, 'crash');
                } else {
                    playSfx('sfx-lose');
                    showResultBanner('ğŸ˜­', type === 'up' || type === 'down' ? 'çŒœéŒ¯äº†' : 'æ²’é€²...', deltaAmount, 'lose');
                }
                if (refillTriggered) showRefillToast(localData.entryFee, pKeys.length);
            });
        } else {
            playSfx('sfx-fold');
            showResultBanner('ğŸ³ï¸', 'æ£„ç‰Œ', deltaAmount, 'fold');
            if (refillTriggered) showRefillToast(localData.entryFee, pKeys.length);
        }
    }

    function renderUI(isHost) {
        document.getElementById('pool-val').innerText = localData.pool || 0;
        document.getElementById('status-msg').innerText = localData.statusMsg || "";
        document.getElementById('cards-left').innerText = localData.deck ? localData.deck.length : 0;
        document.getElementById('fold-cost-ui').innerText = localData.foldPenalty || 20;
        updateCard('c1', localData.c1);
        updateCard('c2', localData.c2);
        updateGateCard(localData.c3);

        const isTurn = (localData.currentPlayerKey === myId);
        const board = document.getElementById('main-board');
        if (isTurn) { board.classList.add('my-turn'); } else { board.classList.remove('my-turn'); }

        // ç‰Œå †é»æ“Šç‹€æ…‹
        const deckEl = document.getElementById('deck-stack');
        const hintEl = document.getElementById('deck-hint');
        const deckBadge = document.getElementById('deck-badge');
        if (deckBadge) deckBadge.innerText = localData.deck ? localData.deck.length : 0;
        if (isTurn && localData.gameState === 'waiting_deal') {
            deckEl.classList.add('can-click'); hintEl.innerText='é»æ“ŠæŠ½ç‰Œ'; hintEl.classList.add('show');
        } else if (isTurn && localData.gameState === 'waiting_shoot') {
            const isSameD = localData.c1 && localData.c2 && localData.c1.val === localData.c2.val;
            deckEl.classList.add('can-click'); hintEl.innerText = isSameD?'ä¸‹æ³¨å¾ŒçŒœå¤§/çŒœå°':'ä¸‹æ³¨å¾Œé»æ“Šå°„é–€'; hintEl.classList.add('show');
        } else {
            deckEl.classList.remove('can-click'); hintEl.classList.remove('show');
        }
        // åŒæ­¥æ©¢åœ“æ¡Œå½©é‡‘
        const op = document.getElementById('oval-pool-text');
        if (op) op.innerText = 'ğŸ’° $' + (localData.pool || 0);
        // éš±è—èˆŠç™¼ç‰ŒæŒ‰éˆ•ï¼ˆæ”¹ç‚ºé»ç‰Œå †ï¼‰
        document.getElementById('player-deal-btn').style.display = 'none';
        document.getElementById('bet-controls').style.display = (isTurn && localData.gameState === 'waiting_shoot') ? 'block' : 'none';
        const isSame = localData.c1 && localData.c2 && localData.c1.val === localData.c2.val;
        document.getElementById('shoot-normal').style.display = isSame ? 'none' : 'inline-block';
        document.getElementById('guess-buttons').style.display = isSame ? 'inline-block' : 'none';
    }

    // æ›´æ–°é¾é–€ä¸­é–“æ ¼é¡¯ç¤º
    function updateGateCard(c) {
        const gateInner = document.getElementById('gate-inner');
        const c3InGate = document.getElementById('c3-in-gate');
        if (!c) {
            gateInner.style.display = '';
            gateInner.innerText = 'å¾…å°„é–€';
            c3InGate.style.display = 'none';
            c3InGate.innerHTML = '';
        } else {
            gateInner.style.display = 'none';
            const isRed = c.suit === 'â™¥' || c.suit === 'â™¦';
            c3InGate.style.display = 'block';
            c3InGate.innerHTML = `<div class="card ${isRed ? 'red' : ''}" style="width:clamp(70px,15vw,90px);height:130px;">${c.suit}\n${c.label}</div>`;
        }
    }

    function addBet(v) {
        let cur = parseInt(document.getElementById('bet-amount').value) || 0;
        document.getElementById('bet-amount').value = Math.min(cur + v, localData.pool);
    }

    // ALL IN éŠæˆ²å…§ç¢ºèª
    function setAllIn() {
        document.getElementById('allin-pool-preview').innerText = '$' + (localData.pool || 0);
        document.getElementById('all-in-confirm-overlay').classList.add('show');
    }
    function cancelAllIn() {
        document.getElementById('all-in-confirm-overlay').classList.remove('show');
    }
    function confirmAllIn() {
        document.getElementById('all-in-confirm-overlay').classList.remove('show');
        gameRef.update({ allInTrigger: getServerNow().toString() });
        document.getElementById('bet-amount').value = localData.pool;
    }

    // æ›´æ–°å·¦æŸ±/å³æŸ±ç‰Œï¼ˆc1, c2ï¼‰
    function updateCard(id, c) {
        const el = document.getElementById(id);
        if (!c) { el.classList.add('hidden'); el.innerText = '?'; }
        else {
            el.classList.remove('hidden');
            el.innerText = `${c.suit}\n${c.label}`;
            el.classList.toggle('red', c.suit === 'â™¥' || c.suit === 'â™¦');
        }
    }

    function generateDecks(count) {
        let deck = [];
        const suits = ['â™ ', 'â™¥', 'â™¦', 'â™£'];
        for (let i = 0; i < count; i++) suits.forEach(s => { for (let v = 1; v <= 13; v++) deck.push({ val: v, suit: s, label: labels[v] || v }); });
        return deck.sort(() => Math.random() - 0.5);
    }

    function kickPlayer(id) { if(confirm("å‰”é™¤è©²ç©å®¶ï¼Ÿ")) gameRef.child('players/'+id).remove(); }
    function hostResetToLobby() { if(confirm("é‡è£½å¤§å»³ç‹€æ…‹ï¼Ÿ")) gameRef.update({ gameStarted: false }); }
</script>
</body>
</html>
